% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/gUtils.R
\name{gr.round}
\alias{gr.round}
\title{Round a set of GRanges to another set
"rounds" a set of query ranges Q to a given interval set S using the following rule:
1) If q in Q is partially / fully within S then return intersection of q with S.
2) If q intersects multiple ranges in S and \code{up = F} then return the "first" range, otherwise the last range
3) If q in Q is fully outside of S (ie fully inside not S) then return the \code{start-1} (if \code{up = T}) or \code{end+1} (if \code{up = F})
of the matching range in not S}
\usage{
gr.round(Q, S, up = TRUE, parallel = FALSE)
}
\arguments{
\item{Q}{Query \code{GRanges} (strand is ignored)}

\item{S}{Subject \code{GRanges} (strand is ignored)}

\item{up}{[default TRUE] See description.}

\item{parallel}{[default FALSE] If \code{TRUE}, assumes Q and S are same length and this analysis is only performed between the corresponding Q and S pairs.}
}
\value{
Rounded \code{GRanges}
}
\description{
Round a set of GRanges to another set
"rounds" a set of query ranges Q to a given interval set S using the following rule:
1) If q in Q is partially / fully within S then return intersection of q with S.
2) If q intersects multiple ranges in S and \code{up = F} then return the "first" range, otherwise the last range
3) If q in Q is fully outside of S (ie fully inside not S) then return the \code{start-1} (if \code{up = T}) or \code{end+1} (if \code{up = F})
of the matching range in not S
}
\examples{
\dontrun{query   <- GRanges(1, IRanges(c(100,110),width=201), seqinfo=Seqinfo("1", 500))
subject <- GRanges(1, IRanges(c(160,170),width=201), seqinfo=Seqinfo("1", 500))
gr.round(query, subject)}
}

