% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gUtils.R
\name{gr.val}
\alias{gr.val}
\title{Annotate \code{GRanges} with values from another \code{GRanges}}
\usage{
gr.val(query, target, val = NULL, mean = TRUE, weighted = mean,
  na.rm = FALSE, by = NULL, by.prefix = val, merge = FALSE,
  verbose = FALSE, FUN = NULL, default.val = NA, max.slice = Inf, ...,
  sep = ", ")
}
\arguments{
\item{query}{\code{GRanges} of query ranges whose \code{val} column we will populate with aggregated values of \code{target}}

\item{target}{\code{GRanges} of target ranges that already have "val" column populated}

\item{val}{If a character field: then aggregation will paste together the (unique), overlapping values, collapsing by comma. \code{[NULL]}}

\item{mean}{Scalar logical flag. If \code{FALSE} then will return sum instead of mean, only applies if target \code{val} column is numeric.}

\item{weighted}{Calculate a weighted mean. If \code{FALSE}, calculates unweighted mean. \code{[TRUE]}}

\item{na.rm}{Remove NA values when calulating means. \code{[FALSE]}}

\item{by}{scalar character, specifies additional "by" column of query AND target that will be used to match up query and target pairs (i.e. in addition to pure GRanges overlap), default is NULL}

\item{verbose}{Increase the verbosity of the output}

\item{FUN}{Optional different function to call than mean. Takes two arguments (value, na.rm = TRUE) if weighted = FALSE, and three (value, width, na.rm = TRUE) if weighted = TRUE}

\item{max.slice}{Maximum number of query ranges to consider in one memory chunk. \code{[Inf]}}

\item{...}{Additional arguments to be sent to \code{\link{gr.findoverlaps}}.}

\item{sep}{scalar character, specifies character to use as separator when aggregating character "vals" from target, only applies if target is numeric}

\item{if}{merge = FALSE then will cross every range in query with every level of "by" in target (and create data matrix), otherwise will assume query has "by" and merge only ranges that have matching "by" values in both query and target}
}
\value{
\code{query} with the \code{val} field populated
}
\description{
Annotates \code{GRanges} in \code{query} with aggregated values of \code{GRanges} in \code{target} in field \code{val}.
If \code{val} is numeric: given \code{target} with value column \code{target} representing ranged data
(i.e. segment intensities), thn computes the value
in each \code{query} \code{GRanges} as the weighted mean of its intersection with target
(ie the target values weighted by the width of the intersections).
}
\details{
Applications include (among others):
\itemize{
\item Querying the average value of target across a given query interval (e.g. exon to gene pileup)
\item recasting a high res tiling in terms of low res intervals.
}
Usually query intervals are bigger than the target intervals.
}
\note{
\code{query} and \code{target} can be \code{GRangesList} object, in which case val will refer to \code{GRangesList} level values fields
}

